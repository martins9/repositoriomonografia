
Linguagens dinâmicas:

-> Ter coletor de lixo, ter eval, ter tipagem dinâmica

==============================================================================================================================
************************************************************* Modulo 1 *******************************************************

1.1 - Sobre as linguagens que aparecem nos slides…
- Quais linguagens que você…

	1. já tinha ouvido falar? em que situação?
	   Já tinha ouvido falar nas seguintes linguagem:
	   Fortran no contexto científico.
	   Python no contexto de aprendizagem de programação. 
	   Java no contexto na aprendizagem de programação.
	   Visual Basic para automação de tarefas.
		
    2. já teve algum contato? em que nível?
	   Fortran nível básico
	   Python nível médio. 
	   Java nível médio.
	   Visual Basic nível básico.
	   
	3. programa com frequência? em que contexto?
       Eu programo não com muita frequência.
	   No contexto de finalização da monografia e
	   realizando algumas tarefas no trabalho.
	
	4. mais teria curiosidade de conhecer? por quê?
	   Queria conhecer um pouco mais da linguagem Groovy 
	   por causa de automação de tarefas e por quê a ferramenta 
	   Jenkins a usa como base.

=====================================================================================================
1.2 - Dentre as linguagens que você já usou...
Dentre as linguagens que você já usou...
    
	1. qual você mais gosta? por quê?
	 O que eu mais usei foi Python, isto foi por causa de uma matéria da faculdade que a usava 
	 como contato inicial com uma linguagem e também para criar os scripts da monografia.
	 Eu gostei desta linguagem por causa do fácil acesso a documentação e por quê a sintaxe
	 é fácil e clara.	 
	
    2. qual você menos gosta? por quê?
	Não diria que eu não gosto, porém que eu tenho dificuldade é com linguagens funcionais, pois 
	ainda não fundamentado o paradigma funcional.
	
========================================================================================================
2.1 - Escolha uma linguagem de sua preferência…
1. Sobre portabilidade...
A linguagem escolhida é Shell Script

a. em que sistemas operacionais ela está disponível?
Ela é roda em Ubuntu, Mint, Fedora e OpenSuse entre outros.

b. em que arquiteturas ela está disponível?
Ela é suportada nas seguintes arquiteturas: ARM, Atmel AVR32,
Intel entre outros.

c. em que sistema ou arquitetura ela não está disponível?
Ele não está disponível para Windows nativamente. Sabendo que 
existe que tem várias interfaces que no Windows podem rodar 
Shell Script como Cmder terminal, Terminal do Ubuntu para 
o Windows.

2. Sobre abstrações de dados…

a. que abstrações diferentes/especiais ela possui?
Uma abstração de dado que é diferente no shell Script é 
o redirecionamento de fluxo ">". Esta abstração 
permite redirecionar a saída padrão de um comando para 
entrada padrão de outro comando. Ou permite um pograma 
receber entrada de argumentos com via redirecionamento 
de fluxo.

b. que abstrações comuns ela não possui?
Creio que uma abstração que ela não possui é a soma 
de números, pois isso não é nativo do Shell Script, portanto
foi criado uma biblioteca chamada BC para realizar o cálculo.

3. Sobre abstrações de controle…
a. que abstrações diferentes/especiais ela possui?
No Shell Script as condições do if são diferente de outra
linguagem, estas são:
- eq : (equal) Igual à
- ne : (not equal) Diferente de
- lt : (less than) Menor que
- gt : (greater than) Maior que
- le : (less or egual) Menor ou igual à
- ge : (greater or equal) Maior ou igual à

Outra condição que o Shell Script é o "until":
O until é usado para executar um determinado conjunto de comandos, 
desde que a condição fornecida seja avaliada como falsa. Ver o 
exemplo abaixo e a saída:

#!/bin/bash

counter=0

until [ $counter -gt 5 ]
do 
	echo Counter: $counter
	((counter++))
done

Counter: 0
Counter: 1
Counter: 2
Counter: 3
Counter: 4
Counter: 5

b. que abstrações comuns ela não possui?
Shell Script possui abstrações comuns como: 
if,else, while, case e etc.

================================================================================================
2.2 - Escolha uma linguagem de domínio específico de sua preferência…
- Como a linguagem de domínio específico ajuda na produtividade? Dê exemplos.

A linguagem escolhida foi o Shell Script, pois o seu domínio é exclusivamente para interagir
com o sistema operacional baseado em Unix. Ela ajuda na produtividade, pois o desenvolvedor 
se fizemos algumas operações que o Shell faz deveria desenvolvê-la ou usar alguma biblioteca 
específica, abaixo um exemplo.

Em Linux, se eu quiser colocar uma variável de ambiente "temporária", pois quando o terminal 
encerrar a variável não irá mais existir, então devo fazer do seguinte modo:

export PASS="123"

Portanto, se eu quiser fazer o mesmo procedimento na linguagem Python eu devo chamar uma biblioteca
externa chamada OS, este fornece funções para interagir com o sistema operacional e devemos fazer do 
seguinte modo:

import os
os.environ["PASS"] = "123"

- Observações:
- Não vale SQL e nem linguagens de descrição de dados sem suporte a lógica de programação (ex., JSON/HTML/CSS/etc)
- Se a resposta dada também se aplica a uma biblioteca hipotética em uma linguagem de propósito geral (ex., #include "matrix.h"), então não é uma boa resposta.
- Uma boa resposta vai ter até 2 parágrafos e pelo menos um exemplo completo com uma indicação de como ele ficaria complicado em outra linguagem (ex., Python).

============================================================================================================================================================================

3.1 - Explique com suas próprias palavras o que você entende por semântica no contexto de linguagens de programação.

Semântica no contexto de linguagem de programação ao meu entender é o sentindo em que as regras (sintaxe) todas 
juntas em um programa faz sentindo ou não, pois um programa com todas as regras (sintaxe) escritas de maneira correta
podem não fazer sentindo no momento da execução e, assim, impactar o comportamento esperado do programa.
Pois, a semântica influencia  no comportamento de um programa, por exemplo, quando em Pyhton tentamos somar um valor 
inteiro com uma string. 
a=10
a+'x'

Vimos que o erro gerado é na camada da semântica, pois estamos tentando somar duas primitivas que não podem ser somadas, 
portanto o comportamento do programa (semântica) está equivocado mesmo que as regras (sintaxe) estejam corretas.

==========================================================================================================================================================================
3.2 - Dê exemplos de abstrações que escondem detalhes da entrada, saída, memória e CPU.

- Pelo menos um exemplo de cada.
- Use o nome de comandos / funções reais de uma linguagem de programação.
- Não vale os que já estão nos slides ("input", "print", variáveis, "for").
- Para a CPU, procure ser criativo e evite uma abstração muito comum.

Abaixo todos os exemplos usando Shell Script

1. Abstração de entrada 
# Neste ponto copiando um arquivo do pendrive para o home do usuário
no sistema operacional

cp /media/smsf/MARTINS/rufus-usb-3-3.exe /home/smsf/


2. Abstração de saída
# Esse código enviar um arquivo db.sql para um servidor 
para o destino /tmp

scp db.sql carolina@152.92.234.57:/tmp/db.sql


3. Abstração de memória
#Cria um arquivo temporário
tmpf=`mktemp`

#Guarda todo o conteúdo do caminho informado
ls -l "$1" &gt;$TMPF


4. Abstração do CPU
# Neste ponto aborta todos os processos de java 

ps -ef | grep java | kill -9 $(awk '{print $2}')

==============================================================================================================================
3.3 - Descreva a sintaxe e semântica do comando for de C.

A sintaxe de for:
Começando com a palavra reservada é o For seguindo de parênteses. Dentro do parênteses temos as seguintes
instruções: o passo inicial para o laço de for, a condicional para o laço de repetição e o incrementador. 
Por fim, a declaração dentro do escopo do laço de repetição.

for (inicialização; teste; incrementador)
{
	declarações
}

A semântica de for:

O comando for é um comando de repetição em que possui um conjunto de instruções para execução em que contém 
a inicialização para o laço de repetição, uma condição que delimita o laço de repetição e esta é testada e 
o incrementador que é aumentado ou subtraído (em cada caso) em cada laço. 
Enquanto a condição de teste é verdadeira a declaração (comandos) dentro do escopo do laço de repetição é 
executada e caso é falso, então a declaração não é executada.
Abaixo um exemplo do comando for:

for (int i=0; i<=5; i++){
	
	printf("%d ",i)
}

==============================================================================================================================
3.4 - Descreva a sintaxe e semântica de chamada de funções em Python.

Sintaxe de chamada de função:

Dado uma função já criada como:
	def NomedaFuncao(ar1, arg2):
	  <codigo>
    return NomeDoObjetoARetornar
   
Então, a chamada da função é feita pelo nome dela passando os argumentos devidos:
NomedaFuncao(ar1, arg2)


Semântica de chamada função:
Partindo da premissa que uma função já esteja criada, então a sua chamada é feita
pela declaração do seu nome passando os parâmetros que foram definidos na declaração 
da função, evidentemente se esses parâmetros foram declarados, senão a função não 
terá dados de entrada.
Quando função é chamada, então é executado os comandos que foram declarados dentro do
escopo da função e os mesmos só existiram dentro desse escopo.
A função terá retorno tendo caso a mesma seja declarada no seu escopo, caso contrário a 
função não terá. No cenário em que uma função é passada como parâmetro para outra função, 
então ambas são colocadas na pilha (memória), porém a função que foi passada como parâmetro 
é executada primeiro para depois a segunda ser executada com o resultado da primeira que foi
passada como parâmetro e, assim, estendo para outras chamadas. 
==============================================================================================================================

3.5 - Pesquise e descreva as principais diferenças semânticas entre Python 2 e Python 3.

Há algumas diferenças entre Python2 e Python3 como:

1) No Python3 as strings são armazenadas como Unicode, porém no Python2 as strings são 
armazenadas como ASCII e se quiser armazenar como Unicode, então deve adicionar "u" na 
frente da string. 

2) No Python2 se fizermos a divisão 2/3, então o resultado será 2 por causa do arrendontamento, 
porém se quisermos a precisão decimal, então deveríamos escrever do seguinte modo: 5.0/2.0 
para obter a resposta exata 2,5. Agora, no Python3 a divisão 2/3 retornará a precisão decimal 2,5.

3) No Python2 range retorna uma lista, porém agora no Python o range retornar um iterador, 
então é necessário criar uma lista se for o casdo.

4) No Python2 poderia realizar comparações, por exemplo:
>>> '3' > 2 
True

Agora, no Python3 não pode ser realizado mais essas comparações, pois é gerado uma exceção, pois 
é reconhecido que é uma comparação entre string e int. 
>>> '3' > 2
Traceback (most recent call last):
 
   File "<stdin>", line 1, in <module>
 
TypeError: unorderable types: str() > int()
=============================================================================================================================

4.1 - Qual é a diferença fundamental entre linguagens imperativas e linguagens funcionais?

As linguagens que se dizem imperativas tem como influência a arquitetura de von Neumann e, assim, são executadas nesse tipo
de arquitetura. Neste contexto, a memória guarda as variáveis e a CPU executa as instruções, pois uma linguagem imperativa 
possui uma sequência de instruções, com blocos de comandos e atribuição de variáveis. Sabendo que um ponto importante é 
as variáveis guardam o estado atual do programa. Exemplo abaixo:

int total = 0;
int number1 = 5;
int number2 = 10;
int number3 = 15;
total = number1 + number2 + number3;

Uma linguagem funcional diferente de uma linguagem imperativa não guarda o estado atual do programa, pois como é composto
por funções, pois segue um conceito matemático de conjunto domínio e um conjunto imagem. Então, as funções manipulam 
conjunto de dados. Portanto, o computador trabalha como um avaliador de expressões que são declaradas no código. 
E um ponto importante que uma linguagem funcional tem o controle do programa que ocorre muito das vezes por recursão. 
Exemplo abaixo:

ls = [2,3,4,5]
dobrarLista ls = map (\x -> 2 * x) ls

Referências:

1. Paradigma Funcional
https://www.inf.pucrs.br/~gustavo/disciplinas/pli/material/paradigmas-aula15.pdf

2. Linguagens Imperativas & Linguagens Funcionais
http://www.ppgsc.ufrn.br/~rogerio/material_auxiliar/CLP20131_linguagens_imperativas_funcionais.pdf

=============================================================================================================================

4.2 - Na sua opinião, por quê o paradigma de orientação a objetos se tornou tão popular?

- Não é suficiente somente enumerar as características de OO. É preciso justificar.
- Exemplos ajudam.

Creio que o paradigma de orientação a objetos é famoso, pois além das empresas 
adotarem ela como uma ferramenta de desenvolvimento de software. A mesma fornece
características como: 

1) Reutilização de código é muito importante quando se leva em consideração o tempo
de desenvolvimento de um software, isto é proporcionado pela fácil escrita em linguagens
que utilizam POO, pois assim podem ser criadas bibliotecas para serem utilizadas

2) A fácil manutenção e leitura de código baseado em uma linguagem que utilize POO, 
pois mesmo que seja veborrágico não fica mais ao cargo de uma pessoa que detém o 
conhecimento do sistema, então assim a manutenção e leitura pode ser feita por 
qualquer desenvolvedor que tenha os fundamentos de POO.

3) O constante desenvolvimento e suporte a uma linguagem que utiliza o POO a torna 
mais confiável, por exemplo, Java que é suportado pela Oracle. 

4) A adoção de linguagens que utilizam o POO em diversas áreas como: desenvolvimento
de software, desenvolvimento de aplicativos Web, desenvolvimento de testes automatizados
entre outros o torno cada dia mais popular.

==============================================================================================================================

4.3 - Explique com suas próprias palavras a função "eval" de Python 3.

A função eval permite que, em tempo de execução, seja realizada a análise o argumento da expressão e o avalia 
como expressão Python. Em outras palavras, podemos dizer que essa função analisa a expressão passada a ela e 
executa a expressão python (código) dentro do programa. 
Veja o exemplo abaixo:

import os
eval('os.getcwd()')
‘/home/smartins’

Vimos no exemplo acima, que o comando passado que é de um pacote de "OS" é avaliado e executado e, assim,
mostra o diretório corrente em que o usuário se encontra.

==============================================================================================================================

4.4 - Dê um exemplo de outra característica de linguagens dinâmicas.

* Reflexão
Uma característica de linguagem dinâmica é a Reflexão que é a capacidade de uma linguagem de inspecionar e chamar dinamicamente
classes, métodos, atributos e modificá-los em tempo de execução . Este é um recurso relativamente avançado, por isso deve ser usado 
por desenvolvedores que possuem um domínio da linguagem que tem essa funcionalidade, pois com ela pode trazer desvantagens como:
Sobrecarga de desempenho, Restrições de Segurança.

Abaixo um exemplo:

class TesteReflection:
		def __init__(self):
			self.x = 1
		

xx = TesteReflection()
a = xx.__dict__
>> {'x':1}

a['y']= 2
print (xx.y)
>> 2

Descrevendo o exemplo acima em passos:
1) No exemplo acima foi declaro uma classe com o seu construtor com a variável "x" com o valor 1.
2) Após isto, foi instanciado a classe e atribuído a variável xx. 
3) Foi atribuído a variável "a" recuperando o valor da variável da instância usando o atributo "__dict__" que guarda
os atributos da instância. 
4) Foi criado em tempo de execução uma segunda variável "y" e atribuído o valor 2. 
5) Foi printado o valor da variável de instância "y" que retornou. 

Assim, podemos ver a implicação de Reflexão usando Python.

==============================================================================================================================

4.5 - Escolha duas áreas da computação e defenda o uso de uma linguagem para cada uma delas.

* Computação Científica
Na área de computação Científica que a usa computação não como estudo, porém como ferramenta 
para estudar fenômenos da sua área de estudo, áreas como: Físca, Matemática, Biologia entra outros.
Então, para realizar esse é utilizado até uma linguagem chamada Fortran (IBM Mathematical Formula 
Translation System). Pois, como na área científica a demanda por cálculo complexos e processamento 
de dados é grande, então se faz necessário o uso de uma linguagem com poucas abstrações. 
Hoje em dia área científica está sendo dominada por Python e Julia que são linguagens mais modernas
e com outros recursos que auxiliam nas áreas científicas. 

* Empresas e Negócios
Na área de empresas e negócios creio que as linguagens dominantes são linguagens com paradigma OO, 
pois há uma grande oferta de trabalho, programadores, livros, certificações e suporte dessas linguagens, 
um exemplo é a Oracle que suporta a linguagem Java.
Destaco as linguagens Java e C#, estas são utilizados por um sistema estático de tipagem de variáveis e 
forte gerenciamento de memória (Java é um exemplo) que evita bugs quando o software está em execução.
Um linguagem que vem crescendo é Groovy que utiliza o paradigma OO, esta é muito utilizada em automação 
de tarefas.
 
==============================================================================================================================

4.6 - Leia o artigo “Beating the Averages” de Paul Graham e explique com suas próprias palavras o “Paradoxo de Blub”.

O paradoxo de Blub é descrito como uma situação em que o programador realiza um comparativo entre a linguagem 
que ele utiliza que é a Blub, uma linguagem de "meio-termo", e outra linguagem qualquer. Quando o programador 
realiza esse comparativo ele diz que a linguagem abaixo de Blub necessita de um esforço maior de programação, 
pois não tem funcionalidade X, logo a linguagem Blub é uma excelente escolha. Agora, uma linguagem com um nível 
mais alto que Blub não são necessárias, pois o programador de Blub só tem o seu paradigma como referência. 
Agora, por outro lado um programador de uma linguagem com o nível superior a linguagem Blub acha a mesma 
insuficiente, pois ela não possui funcionalidade Y que tem na linguagem que ele programa.
 
==============================================================================================================================

5.1 - Descreva em linhas gerais um trabalho ou projeto que você tenha participado...

Um projeto que participei foi em automação de testes de um sistema financeiro.

- Quais seriam os 2 critérios *externos* mais importantes para esse projeto? Justifique.
Os critérios mais importante para esse projeto foram: Rapid development e Easy maintenance
pelos seguintes pontos abaixo:
-> Rapid development
Como todos os envolvidos tinham conhecimento da linguagem e das outras feramentas utilizadas
para desenvolver os testes, então não "gap" de conhecimento para realizar o trabalho. 

-> Easy maintenance
Ao fim do contrato de desenvolvimento teve período de manutenção, então outra equipe 
assumiu a tarefa, então a linguagem junto com as boas práticas que foram utilizadas 
favoreceu uma boa manutenção. 

- Qual linguagem foi usada no projeto e qual seria a melhor (ou similar)? Justifique.
A linguagem utilizada foi Java, porém uma linguagem que poderia ser utilizada como 
similar seria Python, pois além de suportar o paradigma OO ele também atende os 
critérios externos mencionados acima.

==================================================================================================================================

5.2 - Descreva em linhas gerais um trabalho ou projeto que você tenha participado...

Seguindo a linha do projeto de automação de teste que participei que foi dito no 
exerício 5.1. 

- Quais seriam os 2 critérios *internos* mais importantes para esse projeto? Justifique.

- Consistency 
A linguagem escolhida que leva em conta o paradigma OO não contém inconsistências desnecessárias,
por isso há uma uniformidade para programar sendo assim mais eficaz em não gerar dúvidas sobre o 
comportamento do programa. Logo, não haverá surpresas da linguagem em si quando há bateria de 
testes era realizada sobre o sistema. 

- Abstração
Como escrever testes automatizados requer em vários momentos níveis de abstrações de memória, 
interações com drives e outros sistemas, então se faz necessário uma linguagem que suporte 
isso de uma forma que seja viável a escrita do códio e fornece vários modos de realizar 
esta tarefa. 

- Qual linguagem foi usada no projeto e qual seria a melhor (ou similar)? Justifique.
A linguagem escolhida foi Java, porém creio que uma linguagem similar que poderia 
ser usada, pois possui o mesmo paradigma OO tem as mesmas primitivas e também é 
fortemente usado no mercado de trabalho para automação de testes é o C#.

==================================================================================================================================

5.3 - Dê um exemplo de inconsistência ou não ortogonalidade entre funcionalidades de uma linguagem de sua escolha (exceto C).

1. Explique o problema e a razão pela qual existe.
2. Mostre um trecho de código ilustrativo.

Abaixo um exemplo de não ortogonalidade na linguagem Python que é dinamicamente tipada. Por isso se quisermos realizar a soma de uma 
lista de inteiros só precisamos fazer da seguinte maneira:

def somarValorLista(lista):
    soma = 0
    for i in range(0, len(lista)):
        soma = lista[i] + soma
    return soma

lista = [2, 3, 4, 5]
print(somarValorLista(lista))
>> 14

Agora, dado um momento pedimos a entrada de um valor, então fazemos do seguinte modo:

def somarValorLista(lista):
    soma = 0
    for i in range(0, len(lista)):
        soma = lista[i] + soma
    return soma


lista = [2, 3, 4, 5]
valor = input('Insira qualquer valor:')
lista.append(valor)
print(somarValorLista(lista))

Porém, senão nos atentarmos e não realizamos cast do valor de entrada para int, então teremos uma exceção, pois na lista 
será adicionado um char do valor de entrada invés de um int, portando o interpretador tentará "somar" um int com um char. 

Traceback (most recent call last):
  File "D:\ProjetosPython\ProjetosPyhton1\listaorto.py", line 11, in <module>
    print(somarValorLista(lista))
  File "D:\ProjetosPython\ProjetosPyhton1\listaorto.py", line 4, in somarValorLista
    soma = lista[i] + soma
TypeError: can only concatenate str (not "int") to str


===================================================================================================================================

5.4 - Pesquise dois códigos que façam a mesma coisa, mas em linguagens diferentes, e discuta sobre a legibilidade e redigibilidade
de ambos.
- O código deve ter algo único/especial/característico das linguagens para a comparação fazer sentido.
- Não use comparações que envolvam ou não a existência de bibliotecas.
- Evite exemplos muito simples.
- Use linguagens de alto nível.

/*
 Linguagem Java 
*/
public class Principal {

	public static void main(String[] args) {
		
			String text = "saulo";
			String clean = text.replaceAll("\\s+", "").toLowerCase();
			int tamanho =  clean.length();
			int defrente = 0;
			int pratras = tamanho - 1;
			
			boolean variavelBool = true;
			while (pratras > defrente) {
				
				char defrenteChar = clean.charAt(defrente++);
				char pratrasChar = clean.charAt(pratras--);
				if (defrenteChar != pratrasChar)
					variavelBool=false;
			}	
	
			System.out.println(variavelBool);
	}
}

'''
Linguagem Python 
'''
	def ehPalindrome(name):
		return name == name[::-1]


	name = "arara"
	checar = ehPalindrome(name)

	if checar:
		print(True)
	else:
		print(False)

O objetivo dos dois códigos é palíndromo que é uma palavra, frase ou qualquer outra sequência de unidades que tenha a propriedade de poder ser 
lida tanto da direita para a esquerda como da esquerda para a direita. No primeiro exemplo está codificado em Java (linguagem estática) e no 
segundo em Python (linguagem dinâmica). Agora, em característica de regibilidade e legibilidade temos as seguintes características: em Java a
legibilidade é maior do Python, porém em regibilidade em Python é maior.

=================================================================================================================================================

6.1 - Sobre a frase de Alan Perlis a seguir...
"A language that doesn't affect the way you think about programming, is not worth knowing."
(Uma linguagem que não afeta a maneira como você pensa sobre programação, não vale a pena conhecer.)

1. Você concorda ou discorda da frase? Por quê?
Sim. Concordo com essa frase, pois cada linguagem de programação tem um propósito a ser cumprido, 
então quando se aprende uma nova linguagem estamos aprendendo um novo paradigma que modifica a forma
de pensar e programar e, com isso, iremos resolver o mesmo problema ou novos de outra forma. Assim,
creio que se a forma de pensar com uma nova linguagem, então creio que não vale a pena aprender. 

2. Qual a relação entre essa frase e a discussão sobre expressividade em linguagens de programação?
Creio que essa frase tem uma relação com a nova forma de programar, pois se essa nova forma de programar 
for mais efetiva, então pode impactar na expressividade da mesma, todavia deve fazer avaliar o poder de 
expressividade que essa linguagem vai proporcionar perante a uma linguagem já existente.

===============================================================================================================================
************************************************************* Modulo 2 ********************************************************

1.1 - Sobre identificadores em LISP (e/ou derivados)…

1. Quais caracteres podem ou não ser usados como identificadores?
Os identificadores em Lisp são simplesmente variáveis em um programa. E a maioria dos identificadores permitidos por outras 
linguagens de programação também são aceitáveis em Scheme. Em geral os identificadores são uma sequência de letras, dígitos e 
"caracteres alfabéticos". Além disso, +, - e ... são identificadores, assim como uma sequência de letras, dígitos e caracteres 
alfabéticos estendidos que começa com a sequência de dois caracteres.
Não podem ser usados como identificadores: parênteses, colchetes, chaves, ponto, dois pontos, e comercial, pipe, aspas simples 
entre outros.

2. Por quê esses caracteres não são permitidos em outras linguagens? Em outras palavras, por quê em outras linguagens esses caracteres 
*precisam* ser reservados?
Eles não são permitidos em outras linguagens, pois nelas na maioria das vezes são palavras reservadas definidas na fase de projeção 
da linguagem, portanto o compilador/interpretador ao realizar a análise sintática irá acusar erro sobre uma variável que esteja 
fora do padrão projetado. Outro ponto que um interpratador/compilador deveria ter a mesma avaliação de expressão/funções em que 
Lisp foi projetado, ou seja, na linguagem Lisp o elemento mais a esquerda é um operador e o resto são interpretados como nomes 
de variáveis. 


1.2 - Sobre símbolos em LISP/Ruby ou átomos em Erlang…

1. o que são?
Átomos são elementos básicos de uma expressão em linguagem funcionais. Existem três tipos de átomos: numérico, string ou símbolo.
Um átomo sendo numérico ou string, então ele é avaliado e retorna o mesmo. Agora, os símbolos são diferentes, pois são nomes 
utilizados para representar um dado referenciado e a sua avaliação retorna seu valor como dado. 
Outro ponto é átomos são armazenados em uma área de dados separada e nao podem ser excluidos ate o fim da execução do programa.

2. para que servem?
Os átomos tem como responsabilidade constituir a estrutura da expressão funcional. Exemplos de átomos são: a, foo, nill. 
Agora, já os átomos servem para fazer a vinculação de um valor ao nome, por exemplo, na expressão (setq x 8) existem 
três átomos: setq, x e 8.

3. se parecem com qual funcionalidade de outras linguagens?
Os átomos tem semelhança com uma funcionalidade conhecida de outras linguagens chamada enum, pois como átomos são 
são um literal, uma constante com o nome, então podemos realizar esse de-para com essa funcionalidade.

4. que usos interessantes você encontrou?
Abaixo um exemplo de exemplos que são formados por uma sequência ou coleção de objetos arbitrários em uma expressão:
(); é uma lista com um átomo nil ou lista vazia
(1 2 3) ; é uma lista com 3 átomos numéricos
("foo" "bar"); uma lista de duas strings
(x 1 "foo"); uma lista de um símbolo, um número e uma string


1.3 - Sobre os prefixos em variáveis Perl...

1. quais são e o que representam?
A linguagem Perl utiliza três tipos de prefixos para identificar tipos de 
variáveis diferentes que são:
$ é usado para scalars.
@ é usado para arrays.
% é usado para hashes. 

2. quais são as 6 regras de conversão existentes entre eles? (ex., $xxx = @yyy)

	1. Conversão $escalar=@array
	Quando uma variável denotada por @array é atribuída à uma variável escalar escrita na forma $escalar, o Perl 
	identifica o contexto dessas variáveis e atribui à $escalar apenas o número de elementos neste array, assumindo 
	que o contexto é escalar. 

	2. Conversão $escalar=%hash
	Quando uma variável tipo hash, com notação %hash é atribuída a uma variável escalar com sintaxe $escalar, o Perl se
	comporta de forma similar ao caso anterior, com arrays, atribuindo à variável escalar o tamanho da hash, isto é, a 
	sua quantidade de pares chave valor. 

	3. Conversão @array = %hash
	Quando uma variável tipo hash é atribuída a um vetor, o Perl atribui à @array um vetor
	contendo os pares de elementos da hash (chaves e valores) em ordem arbitrária. Note que,
	no exemplo abaixo os valores sempre são precedidos de suas chaves nas posições do
	array, contudo, em execuções diferentes, os pares podem alterar as posições no vetor.


2.1 - Escolha um programa escrito em uma linguagem estática (exceto C/C++)...

- Dê dois exemplos de nome/entidade para cada tempo de amarração
- deixe claro qual é o nome (identificador) e qual é a entidade (propriedade) que estão sendo amarrados
- não duplique os exemplos! (não vale mesmo tipo de nome/entidade para o mesmo tempo de amarração)


/**
*	Este programa realiza a soma de dois vetores, somente, de valores pares
*/
package edl;

import java.util.Arrays;

public class Principal {

	public static void main(String[] args) {

		int[] veta = { 1, 2, 3, 4 };
		int[] vetb = { 10, 12, 13, 14 };
		int[] vetc = new int[tamanhoDinamico(veta, vetb)];

		int index = 0;
		for (int i = 0; i < veta.length; i++) {

			if (veta[i] % 2 == 0 && vetb[i] % 2 == 0) {
				vetc[index] = veta[i] + vetb[i];
				index += 1;
			}
		}

		System.out.print(Arrays.toString(vetc));

	}
}

tempo de design: amarração dos nomes “if” e “for” como palavras reservadas.
tempo de implementação: tamanho de “int” e tipo do método que é "void".
tempo de pré-processamento: valores para os vetores de veta = { 1, 2, 3, 4 } e vetb = { 10, 12, 13, 14 }.
tempo de compilação: semântica do símbolos “+”, “<” e “>” em seus contextos.
tempo de link-edição: assinatura do método tamanhoDinamico(veta, vetb) e Arrays.toString(vetc).
tempo de carregamento: endereços das variáveis “index” e os espaços de endereçamento dos vetores “veta”, “vetb” e “vetc”.
tempo de execução: O resto da divisão veta[i] % 2 e vetb[i] % 2 e a soma dos dos valores dos vetores: veta[i] + vetb[i].


2.2 - Escolha um programa escrito em uma linguagem dinâmica...
- Dê dois exemplos de nome/entidade para cada tempo de amarração.
- deixe claro qual é o nome (identificador) e qual é a entidade (propriedade) que estão sendo amarrados
- não duplique os exemplos! (não vale mesmo tipo de nome/entidade para o mesmo tempo de amarração)

'''
 Programa que lê dados de um arquivo, insere em duas listas
 e depois soma os valores das duas listas se forem pares.
'''

file = open("lerArquivo.txt", "r")
texto = file.readlines()

listaSoma = []
count = 0

while count < len(texto):
    texto[count] = texto[count].split(',')
    count += 1

# Esse for abaixo aqui é só para tirar o "\n" em algumas strings, é opcional.
for i in texto:
    local = texto.index(i)  # Local do i em texto
    for b in i:
        local2 = texto[local].index(b)  # Local2 do b em i ( local )
        if "\n" in b:
            texto[local][local2] = b.replace("\n", '')  # Substitui o valor de acordo com "local" e "local2"

lista1, lista2 = texto

for i in range(len(lista1)):
    if int(lista1[i]) % 2 == 0 and int(lista2[i]) % 2 == 0:
        listaSoma.append(int(lista1[i]) + int(lista2[i]))

print(listaSoma)

tempo de design da linguagem: os statements “for” e “print” como palavras reservadas da linguagem.
tempo de compilação: o valor inicial da variável "count".
tempo de execução: valor da variável "file" e "listaSoma".

3.1 - Pegue um programa seu razoavelmente grande...

	1. Enumere todas as declarações/alocações de memória estática, pilha e heap.
	2. Coloque um comentário em maiúsculas para facilitar a localização. Exemplo:
	- int a; // PILHA
	3. O programa deve ter pelo menos 5 usos da pilha e da heap.

Código que cálcula o salário de um profissional

# include <stdio.h>
# include <stdlib.h>
# include <string.h>
# define T 50 // MEMORIA ESTÁTICA
# define M 20 // MEMORIA ESTÁTICA
# define E 100 // MEMORIA ESTÁTICA
# define C 20 // MEMORIA ESTÁTICA
# define CB 10 // MEMORIA ESTÁTICA
# define A 15 // MEMORIA ESTÁTICA
# define CO 15 // MEMORIA ESTÁTICA
# define S 10 // MEMORIA ESTÁTICA

struct informacao //PILHA
{
       char nome [T]; // PILHA
       char mat[M]; // PILHA
       char end [E]; // PILHA
       char cpf[C]; // PILHA
       char cod[CB]; // PILHA
       char agencia[A]; // PILHA
       char conta[CO]; // PILHA
       float valor; // PILHA
                        
};

struct maio // PILHA
{
       char matricula[M]; // PILHA
       int horas; // PILHA
};

void leDados(struct informacao *pessoa, FILE *arq); // PILHA
void lePrecoHora(struct maio *adicionais,FILE *HoraTrabalhada); // PILHA
void calculo( struct informacao *pessoa, struct maio *adicionais, float *total); // PILHA
void imprime (struct informacao *pessoa, float total[S]); // PILHA

main () // HEAP
{
     
      struct informacao pessoa[S]; // PILHA
      struct maio adicionais [S]; // PILHA

      float total[S]; // PILHA

      FILE *arq; // PILHA
      FILE *HoraTrabalhada; // PILHA
      arq = fopen("Funcionarios.txt","r"); // HEAP
      HoraTrabalhada = fopen ("Maio.txt", "r"); // HEAP
      fclose(arq); // HEAP
      leDados(pessoa, arq); // PILHA
      lePrecoHora(adicionais, HoraTrabalhada); // PILHA
      fclose(HoraTrabalhada); // HEAP
      calculo(pessoa, adicionais, total); // PILHA
      imprime(pessoa,total); // PILHA
      
	  
	  free(arq) //HEAP
	  free(HoraTrabalhada) //HEAP
	  
      system("pause"); //HEAP
      
}     
    
void leDados(struct informacao *pessoa, FILE *arq) // PILHA	
{  
     int i=0; // PILHA
      while (!feof(arq)) // PILHA
     {                     
          for (i = 0; i < S; i++)  // PILHA
          {
		fgets(pessoa[i].nome, T, arq); // PILHA				
        fgets(pessoa[i].mat, M, arq); // PILHA					
        fgets(pessoa[i].end, E, arq); // PILHA		
        fgets(pessoa[i].cpf, C, arq); // PILHA
        fgets(pessoa[i].cod, CB, arq); // PILHA
        fgets(pessoa[i].agencia, A, arq); // PILHA		
        fgets(pessoa[i].conta, CO ,arq); // PILHA		
        fscanf(arq,"%f\n", &pessoa[i].valor); // PILHA  
	
          }        
      }
}

void lePrecoHora(struct maio *adicionais,FILE *HoraTrabalhada) // PILHA	
{
     int i = 0; // PILHA
     
     while ( !feof(HoraTrabalhada) ) // PILHA	
       {
           for (i = 0; i < S; i++) // PILHA	
               {
                  fgets(adicionais[i].matricula, M, HoraTrabalhada); // PILHA	
                  fscanf(HoraTrabalhada,"%d\n", &adicionais[i].horas); // PILHA	
               }
       }
     
}     

void calculo( struct informacao *pessoa, struct maio *adicionais, float *total) // PILHA
{     
    int i,j; //PILHA
      
     for ( i = 0; i < S; i++) // PILHA
         for ( j = 0; j < S; j++) // PILHA
     {
         if (strcmp(pessoa[i].mat,adicionais[j].matricula) == 0) // PILHA	     
            total[i] = ((pessoa[i].valor)*(adicionais[j].horas)); // PILHA
     }  
	  
}     

void imprime (struct informacao *pessoa, float total[S]) // PILHA
{     
      int i; //PILHA
      
     for ( i = 0; i < S; i++) // PILHA
     {
	     printf("%s", pessoa[i].nome); // PILHA
	     printf("%s", pessoa[i].cpf); // PILHA         
	     printf("%s", pessoa[i].cod); // PILHA
	     printf("%s", pessoa[i].agencia); // PILHA
	     printf("%s", pessoa[i].conta); // PILHA
	     printf("Total: %.2f \n",total[i]); // PILHA	
	     printf("----------------------------------\n\n"); // PILHA	
     }
}


3.2 - Pesquise sobre a pilha em alguma linguagem ou arquitetura...
	Qual é o tamanho da pilha em bytes?
	Quantas chamadas recursivas são suportadas?
	Quantas locais eu posso guardar em cada chamada?
	Cite suas fontes.

	Em Java a pilha pode variar entre 320kB e 1024kB, sendo 320 kB o limite padrão e 1024kB(1MB) o
	limite máximo para a JVM, sabendo que a pilha pode ser ajustado pelo desenvolvedor. Tendo o
	tamanho de pilha de 320k, já para o limite máximo de 1MB na pilha, são suportadas cerca de
	7000 chamadas recursivas.

	Referências
	JVM stack size specifications:
	https://stackoverflow.com/questions/37026018/jvm-stack-size-specifications
 
4.1 - Qual é o máximo de memória em bytes que o programa a seguir usa em um determinado momento?

	- Explique como você fez o cálculo.
	- Cite as suas fontes.

	int fat (int n) {
		if (n == 0) {
			return 1;
		} else {
			return n * fat(n-1);
		}
	}

	int vec[100];

	void main (void) {
		for (int i=0; i<100; i++) {
			vec[i] = fat(i);
		}
	}

Temos o seguinte raciocínio:
>> 100 posições de memória ocupadas na pilha pela recursão.
>> A posição da variável local "i" que pertence ao for e é ocupada na pilha. 
>> E as 99 posições do vetor a serem ocupadas na região estática da memória 
pela chamada recursiva, pois cada vez que a função recursiva é chamada, então 
o valor da fat é empilhada até chegar ao máximo que é fat(99).

Como todas as variáveis são "int", então temos a seguinte conta:
(100*4) + (1*4)+(99*4) = 800 Bytes

4.2 - Quais são as regiões de memória do Java e como elas são utilizadas pela JVM?

A JVM internamente mantém a Heap e a Pilha, estas são do seguinte modo:
>> Na Heap são armazenados todos os objetos durante a execução de uma aplicação e 
metados das classes e métodos carregados. A memória é dividida em três gerações:

>>> Heap
> Geração Young
Esta geração armazenam os novos objetos criados. Nesta geração são divididas em três
gerações que são Eden, Survivor 0 e Survivor 1. Agora, já passado um tempo os objetos 
podem ser alocados na geração Tenured. 
Outra geração que existe é a Perm, contém os metadados que descrevem classes e métodos 
carregados pela JVM. E, por fim, todas elas possuem a Virtual, caso haja necessidade 
de mais memória. 

>>> Stack
A pilha é dividida em frames para cada método cujos dados não são compartilhados. Quando o
método termina a execução, o quadro de pilha correspondente é liberado, o fluxo retorna ao
método de chamada e o espaço fica disponível para o próximo método. A memória de pilha
cresce e diminui à medida que novos métodos são chamados e retornados, respectivamente, 
alocando e desalocando automaticamente a região. Se essa memória estiver cheia, o Java 
lançará “java.lang.StackOverFlowError”

Citações:

Referências:
1. http://www.mauda.com.br/?p=964
2. https://www.infoq.com/br/articles/intro-memoria-JVM/
3. https://pt.stackoverflow.com/questions/3797/o-que-s%C3%A3o-e-onde-est%C3%A3o-a-stack-e-heap


5.1 - Sobre o conceito de hiding...
- Hiding / Shadowing: esconder a declaração de variáveis.

1. Procure uma linguagem que não permita hiding. O que acontece quando o programador tenta esconder 
uma variável? Ilustre com um exemplo simples de código.
A linguagem COBOL que não permite Hiding/Shadowing de variáveis. E as primeiras versões da linguagem 
não possuíam a diferenciação de escopo em declarações de variáveis sendo elas consideradas variáveis 
globais em todo o contexto do programa. No COBOl quando tenta-se realizar um Shadowing ou Hiding, 
então o compilador gera uma exceção informando que a variável está sendo utilizada. 

2. Quais são as vantagens e desvantagens de permitir ou não permitir hiding?
A desvantagem de usar hiding é que se o programa tiver uma função com muitas linhas de código, 
mesmo com blocos e aninhadas, então o programador pode se perder nas definições dos escopos e, 
assim, pode cometer algum erro no uso da variável. 
Agora, uma vantagem em relação ao hiding, por exemplo, são as heranças de classes em relação a POO, pois 
o programador utilizando a classe filha pode esconder as variáveis da classe pai se for o caso, então 
só ficará acessível se for utilizado o construtor da classe pai.

5.2 - Sobre escopo dinâmico...

1. Quais outras linguagens (além de Perl) possuem escopo dinâmico?
Além do Perl, outros exemplos de linguagens que utilizam escopo dinâmico: LISP, Logo, Power Shell e 
Shell Script.

2. Como o escopo dinâmico funciona em um delas?
No Shell Script, por exemplo, temos uma função chamada: func1 analisa o escopo onde é chamada.
Quando é chamado de dentro de uma func2, por exemplo. Então, ele primeiro procura no corpo de 
func2 um valor x. Se não estivesse definido lá, procuraria no escopo global, de onde func2 foi 
chamado. 

3. Dê um exemplo interessante do seu uso. Ou seja, um exemplo não didático que poderia ser usado na prática.

dir="/home"

remover_arquivos(){
	
	rm $dir/*.csv;
}

limpar_arquivos(){
	
	local dir=$(pwd);
	remover_arquivos;
}

limpar_arquivos();


5.3 - Sobre o tratamento de exceções em Java ou Python…
1. A partir de um erro (throw/raise), como a linguagem determina o ponto de captura da exceção (catch/except)?

Em Python, um erro é capturado a partir do contexto onde a exceção aconteceu, na forma de rastreamento de pilha.
No Python, o módulo traceback é responsável por rastrear essas exceções a partir de um ponto específico do código.
Esse módulo trabalha com a pilha de chamadas para produzir mensagens de erro. Isso significa que dado um statement 
“raise” como manipulador de uma exceção, o traceback realiza um rastreamento na pilha - a partir do ponto da declaração
“raise” - seguindo de baixo para cima na cadeia de chamadas das funções, da mais recente para a menos recente, até 
encontrar o ponto onde a exceção foi gerada.

2. Tratamento de exceções é mais parecido com escopo estático ou dinâmico? Justifique.

Os tratamentos de exceção tem mais similaridade com escopo dinâmico pois avaliam o contexto
de execução e suas amarrações.

3. Mostre um exemplo de código que deixe claro a similaridade com o escopo escolhido.

===============================================================================================================================
************************************************************* Modulo 3 ********************************************************
1.1 - Sobre o conceito de "transparência referencial"...

	1. Explique esse conceito em uma frase com as suas próprias palavras.

	Dada uma função, então podemos determinar o seu resultado, somente, 
	observando os valores dos seus argumentos, ou seja, não iremos 
	impactar na aplicação se somente substituirmos uma função/método 
	pelo seu valor de retorno.

	2. Quais são as principais vantagens de transparência referencial?

	A transparência referencial torna o programa menos sucetível a erros, e 
	mais conciso, portanto pode ser realizada várias chamadas das funções 
	sem a preocupação de ter algum efeito colateral ou algum comportamento 
	inesperado. Isto permite que o programador tenha maior domínio sobre 
	o programa que está sendo desenvolvido. E programas que utilizam de
	transparência referencial são mais fáceis de ler e entender.

	3. Por quê essas vantagens são possíveis?

	Temos dois motivos para que possibilite essas vantagens, que são:
	>> Variáveis
	Elas se comportam mantendo os mesmos valores declarados até o fim da execução do programa.

	>> Funções
	Está relacionado ao fato de as funções serem puras e determinísticas, ou seja, retornam 
	sempre o mesmo resultado para as mesmas entradas.

1.2 - Sobre funções recursivas…

1. Dê pelo menos um exemplo de código de uma função recursiva que você já tenha escrito em trabalhos ou projetos.
Este exemplo é didático, pois foi um código desenvolvido em aula de LP1.
# include <stdio.h>

int mul(int a, int b)
{
	if (b == 0)
		return 0;
	else if (b > 0)
		return (a + mul(a,(b-1)));
}

int main()
{
	int a=0, b=0, mult=0;
		  
	printf("Digite 2 num's: ");
	scanf("%d %d",&a,&b); 

	mult = mul(a,b);
	printf("Multiplicaçao: %d ", mult);
		 
return 0;
}	
 

1.3 - Sobre funções de alta ordem...

1. Dê um exemplo de código que chame uma função de alta ordem que você tenha escrito em trabalhos e projetos.
2. Explique o que faz a função que você passou para a função de alta ordem. Em outras palavras, explique o objetivo da chamada que você escolheu.
3. Por quê você optou por essa técnica?

Este código é executado dentro da ferramenta Atlassian e é utilizado a linguagem Groovy, então foi utilizado closure
e, assim, dentro da each é percorrido para percorrer os elementos das issues e se uma issue é de um tipo 
(criar-usuário-prestador-de-serviços) e o status estiver Fechado e Resolvido, então o contador será acrescido +1.
Este código abaixo foi realizado para quantificar as issues que tem essas características para posteriormente gerar 
um relatório.

IssueService issueService = ComponentAccessor.getIssueService()
IssueInputParameters issueInputParameters = issueService.newIssueInputParameters()
def customFieldManager = ComponentAccessor.getComponent(CustomFieldManager)
def requestType = ComponentAccessor.customFieldManager.getCustomFieldObjectsByName('Customer Request Type')
def cf = customFieldManager.getCustomFieldObjectByName('Data Fim')

def issueManager = ComponentAccessor.getIssueManager()
def issues =  issueManager.getIssueObjects(issueManager.getIssueIdsForProject(10000))

issues.each { elem ->

    if(issueManager.getIssueByCurrentKey(elem.toString()).getCustomFieldValue(requestType).toString() == 'desk/criar-usuário-prestador-de-serviços'
        && issueManager.getIssueByCurrentKey(elem.toString()).getStatus().getName() != 'Fechado' &&
        issueManager.getIssueByCurrentKey(elem.toString()).getStatus().getName() != 'Resolvido'){

        issueList += elem
    }
}
    issueList

1.4 - Sobre declarações múltiplas…
	O exemplo a seguir não adere ao modelo funcional pois possui duas declaração para a variável b.

	a = b * 2
	x = a + b
	b = 10
	b = 0

	- Mas o que deveria acontecer quando o programador comete esse erro em uma linguagem funcional pura?
	Quando o programador comete esse erro, então o compilador irá gerar uma exceção, pois as variáveis 
	em um paradigma funcional são imutáveis até o fim da execução do programa e como podemos ver no 
	na declaração acima a variável "b" é declarada duas vezes.


	2. Explique o caso base e o passo recursivo do algoritmo.

	Este exemplo é para realizar a multiplicação  entre dois números naturais, em que o programa lê dois números
	passados pelo usuário.
	>> Caso Base 
		O caso base é se um dois números passados for zero, então o resultado da multiplicação  será zerado. 
		
	>> Passo recursivo
		Agora, o valor sendo maior que zero, então de forma recursiva será chamado a função mul(a,b-1) e somado
		com o valor inicial da primeira variável e, isso, será feito até que o valor da segunda variável "b" seja
		zero. 
		
	2. Por quê você optou por essa técnica?
		   
	Esta técnica foi usado para reescrever de forma recursiva a multiplicação de dois números naturais.


2.1 - Escreva um programa em C que represente a lista encadeada [1,2,3,4]

#include <stdio.h>
#include <stdlib.h>

typedef struct no No;
struct no{
   int num;
   struct no *prox;
};

//Cria o no para a lista encadeada
No* criar_no(){
  
  No *no=(No*)malloc(sizeof(No));
  return no;
}


/* Inserir o elemento no fim da lista realizando 
a verificacao se o no esta ocupado ou apontando 
para NULL
*/ 
No* inserir_elemento_fim(No *Lista, int dado){
  
  No *no = criar_no();
  no->num=dado;

  if(Lista==NULL){
    no->prox=NULL;
    Lista=no;
  }else{
    No* aux=Lista;
    while(aux->prox !=NULL){

       aux=aux->prox;
    }
    no->prox=NULL;
    aux->prox=no;
  }

  return Lista;
}

// Imprimi a lista encadeada
void imprimirLista(No* Lista){

    No *aux=Lista;
    while(aux!=NULL){
      printf(" %d", aux->num);
      aux=aux->prox;
    }

}

int main(void) {
  int vetor[4] = {1,2,3,4};
  No* lista=NULL;

  for(int i=0; i <=4;i++)
  { 
      lista=inserir_elemento_fim(lista,vetor[i]);
  }
  printf("\n");

  imprimirLista(lista);
  return 0;
}

2.2 - Escreva a função filter em Python usando recursão.

# Funcao de filtro que sera aplicado a lista
def func(elem):
    nova_lista = []
    for elem in elem:
        if elem % 2 == 0:
            nova_lista.append(elem)
    return nova_lista


### Esta funcao recebe a lista e aplica a funcao
def ffilter(lista):
    return func(lista)


# Declaracao da lista
lista = [2, 4, 5, 6, 12]

print(ffilter(lista))


3.1 - Sobre as funções foldl e foldr…

- Execute o passo-a-passo de ambas para as seguintes chamadas:
- foldr (-) 0 [1,2,3,4]
- foldl (-) 0 [1,2,3,4]
- Essas funções são equivalentes? Por quê?

- foldr (-) 0 [1,2,3,4]

[1,2,3,4] 0
4 - 0 = 4 
[1,2,3] 4
4 - 3 = 1
[1,2] 1
1 - 2 = - 1
[1] - 1
- 1 - 1 = -2

- foldl (-) 0 [1,2,3,4]

0 [1,2,3,4]
0 - 1 = -1
-1 [2,3,4]
-1 - 2 = -3
-3 [3,4]
-3 - 3 = -6
-6 [4]
-6 - 4 = -10

As funções não são equivalentes, pois a operação: subtração não é comutativa.


4.1 - Use a função sortBy de Haskell em algum exemplo
- Use algum critério de ordenação não trivial.
- As notas serão comparativas. Exemplos repetidos ou parecidos entre os colegas serão descontados.
- Use a criatividade para evitar repetições.

import Data.List

obter_lista=[("maria", 25), ("joao", 19), ("pedro", 18), ("adriano", 55),  ("carol", 23)]

compara:: (Ord a, Ord b) => (a,b) -> (a,b) -> Ordering
compara (a1, b1) (a2, b2)
        | b1 < b2 = GT  -- greater than 
        | b1 == b2 = EQ  -- equal
        | otherwise = LT -- less than

ordena lista = sortBy compara lista

main = print (ordena obter_lista)


4.2 - Crie um conjunto de dados com listas de tuplas baseado em um cenário real...

--fundoimobiliarios=[("Sigla do fundo imobiliario", P/VP, Nº DE COTISTAS, VALOR ATUAL)]

fundoimobiliarios=[("BNFS11",1.19,3484,123.25),
          ("BBPO11",1.14,65788,114.15),
          ("BBRC11",1.02,8772,117.01),
          ("RBVA11",0.96,39731,109.00),
          ("AGCX11",10.83,39731,1235.50),
          ("SAAG11",0.96,16251,106.61)]

-- Fundos com mais de 30000 cotistas e com P/VP maior que 1 usando filter
func1(v1,v2,v3,v4) = v3 > 30000 && v2 > 1
a = filter func1 fundoimobiliarios

-- Fundos com mais de 30000 cotistas, usando map
func2(v1,v2,v3,v4) = v1
b = map func2 a

-- somando o total do valor de cada ação dos fundos com mais de 30000 cotista e com P/VP maior que 1
func3(v1,v2,v3,v4) = v4
c = map func3 a
soma = foldr (+) 0 c

main = print soma

===============================================================================================================================
************************************************************* Modulo 4 ********************************************************
1.1 - Considere um jogo estilo RPG com personagens Guerreiros, Magos e Sacerdotes...

1. Crie um tipo de dados em Haskell que represente as três classes acima.
2. Crie o mesmo tipo de dados em C usando enum, struct, union.

- Considere que algumas propriedades são comuns às três classes (ex., altura e idade) e outras não (ex., sacerdotes rezam).
- Todas as propriedades devem estar nos subtipos, mesmo as que forem em comum às classes.
- Enumere e explique as propriedades das classes antes de criar os tipos.
- Crie dois exemplos de personagens em cada uma das duas implementações (dois em Haskell e dois em C).

1) Guerreiro:
Caract. físicas: peso, altura, força; // Máx. força = 100
Caract. pessoais: idade, sexo, hp, xp; // Sexo = m ou f e hp = 4000 xp = 5000
Habil. especiais: lutar, cavalgar; // Máx = 5000 para todas as habilidades especiais

2) Mago:
Caract. físicas: peso, altura, força; // Máx. força = 100
Caract. pessoais: idade, sexo, hp, xp; // Sexo = m ou f e hp = 4000 xp = 5000
Habil. especiais: magia, autodefesa; // Máx = 5000 para todas as habilidades
especiais

3) Sacerdote:
Caract. físicas: peso, altura, força; // Máx. força = 100
Caract. pessoais: idade, sexo, hp, xp; // Sexo = m ou f e Máx hp = Máx xp = 5000
Habil. especiais: rezar, curar; // Máx = 5000 para todas as habilidades especiais

>> IMPL. EM HASKELL
data Personagem = Guerreiro Float Float Int Int Char Int Int Int Int
	| Mago Float Float Int Int Char Int Int Int Int
	| Sacerdote Float Float Int Int Char Int Int Int Int
p :: Personagem
p = Guerreiro 81 1.85 100 35 m 2000 3000 4000 2500
p = Mago 100 1.50 100 120 m 4000 5000 4000 5000


>> IMPL. EM C

enum PERSONAGEM { GUERREIRO, MAGO, SACERDOTE }
struct Personagem {
enum PERSONAGEM classe;
union {
	struct { 
				float peso; float altura; unsigned int forca;
				unsigned int idade; unsigned char sexo; unsigned int hp; unsigned int xp;
				unsigned int lutar; unsigned int cavalgar; 
			}; // GUERREIRO
	struct { 
				float peso; float altura; unsigned int forca;
				unsigned int idade; unsigned char sexo; unsigned int hp; unsigned int xp;
				unsigned int magia; unsigned int autodefesa; 
		    }; // MAGO
	struct { 
				float peso; float altura; unsigned int forca;
				unsigned int idade; unsigned char sexo; unsigned int hp; unsigned int xp;
				unsigned int rezar; unsigned int curar; 
			}; // SACERDOTE
	};
};

struct Personagem p = { MAGO 
							{ 
								68, 1.75, 30, 90, f, 4000, 4800, 5000, 3000 
							},
						SACERDOTE 
							{ 
								90, 1.85, 85, 90, m, 4000, 4950, 4535, 4000 
							} 
					  };

2.1 - Considere a definição paramétrica de listas a seguir...
- Crie uma lista que guarde sublistas de inteiros.
- Não use o tipo primitivo de Haskell para listas (ex., [Int]).

lista_A :: Lista Int
lista_A = No 1 (No 2 (No 3 Vazio))
lista_B :: Lista Int
lista_B = No 4 (No 5 (No 6 Vazio))
lista_C :: Lista Int
lista_C = No 7 (No 8 (No 9 Vazio))
lista :: Lista Lista
lista = No lista_A (No lista_B (No lista_C Vazio))



2.2 - Crie um tipo paramétrico para árvores binárias

1. Crie uma árvore binária de booleanos.

data Arvore a = Galho (Arvore a) a (Arvore a) 
				| Folha

arvorebooleano :: Arvore Bool
arvorebooleano = Galho (Galho (Galho Folha true Folha) false (Galho Folha true Folha))
				false Galho (Galho Folha true Folha) false (Galho Folha true Folha)

2. Crie uma árvore em que cada nó guarda uma lista de inteiros.

data Lista a = No a (Lista a) | Vazio

lista_1 :: Lista Int
lista_1 = No 10 (No 20 (No 30 Vazio))

lista_2 :: Lista Int
lista_2 = No 46 (No 55 (No 66 Vazio))

lista_3 :: Lista Int
lista_3 = No 70 (No 80 (No 90 Vazio))

data Arvore a = Galho (Arvore a) a (Arvore a)
				| Folha

arvorebooleano :: Arvore Lista Int
arvorebooleano = Galho (Galho (Galho Folha lista_1 Folha) lista_2 (Galho Folha lista_3 Folha))
